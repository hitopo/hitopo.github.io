{"meta":{"title":"Hitopo's Blog","subtitle":"Start from this moment.","description":"","author":"Hitopo","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-04-03T04:00:55.000Z","updated":"2020-04-03T04:00:56.016Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-04-03T03:39:31.000Z","updated":"2020-04-03T03:43:14.160Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这就是我，是颜色不一样的烟火！"}],"posts":[{"title":"springboot整合vue实现简单的crud","slug":"springboot整合vue实现简单的crud","date":"2020-04-21T09:49:47.000Z","updated":"2020-04-21T09:50:55.435Z","comments":true,"path":"2020/04/21/springboot整合vue实现简单的crud/","link":"","permalink":"http://yoursite.com/2020/04/21/springboot%E6%95%B4%E5%90%88vue%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84crud/","excerpt":"项目简介该项目是在学习了SpringBoot的简单入门和SpringBoot整合Mybatis、Mybatis-Plus插件之后的练手项目 项目实现了用户登录、用户注册；商品的增删改查，商品照片的上传、回显和展示。 项目的技术栈： 后端：SpringBoot、Mybatis、Mybatis-Plus 前端： Vue + ElementUI 项目的仓库地址：https://github.com/hitopo/springboot-learn/tree/master/springboot-vue-crud","text":"项目简介该项目是在学习了SpringBoot的简单入门和SpringBoot整合Mybatis、Mybatis-Plus插件之后的练手项目 项目实现了用户登录、用户注册；商品的增删改查，商品照片的上传、回显和展示。 项目的技术栈： 后端：SpringBoot、Mybatis、Mybatis-Plus 前端： Vue + ElementUI 项目的仓库地址：https://github.com/hitopo/springboot-learn/tree/master/springboot-vue-crud 准备数据库创建数据库springboot-vue-crud，执行db文件夹之下的sql文件创建出数据库和测试数据 导入依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis-plus插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql连接--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring aop支持--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--阿里巴巴druid连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.13&lt;/version&gt; &lt;/dependency&gt; &lt;!--开发热部署插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入Thymeleaf模板--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--文件上传依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置application.yml中添加目前需要的配置 服务器端口、项目路径设置 数据源设置 thymeleaf模板设置 Mybatis-Plus插件全局配置 1234567891011121314151617181920212223242526272829303132server: port: 8080 servlet: context-path: /simple-shopspring: datasource: # 基本配置 driver-class-name: com.mysql.cj.jdbc.Driver username: root password: root url: jdbc:mysql://127.0.0.1:3306/springboot-vue-crud?characterEncoding=utf8&amp;useUnicode=true # 模板设置 thymeleaf: prefix: classpath:/templates/ check-template-location: true suffix: .html encoding: utf-8 mode: HTML cache: false # mybatis-plus插件配置mybatis-plus: # 输出sql语句 configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl mapper-locations: classpath:mapper/**/*.xml global-config: db-config: id-type: auto table-prefix: tb_ 代码生成代码生成是复用上一篇学习Mybatis-Plus那时候的代码，略微做出改动即可使用 统一封装返回的数据格式项目返回的json数据全部固定为指定格式： 12345&#123; \"code\":200, \"msg\":请求成功 \"daat\":&#123;&#125;&#125; 在com.hitopo.common中创建出统一管理返回码和返回消息的枚举类ResultEnum.java 1234567891011121314151617181920212223242526272829303132333435public enum ResultEnum &#123; // 通用返回格式 SUCCESS(200, \"请求成功\"), CREATED(201, \"创建成功\"), DELETED(204, \"删除成功\"), BAD_REQUEST(400, \"请求地址不存在或者包含不支持的参数\"), INNER_ERROR(500, \"服务器错误\"), // 自定义返回的错误格式 // 用户部分 NOT_EXIST_USER_OR_ERROR_PASSWORD(10001, \"用户名或者密码错误！\"), USERNAME_ALREADY_EXIST(10002, \"用户名已经存在！\"), // 文件上传部分 FILE_IS_EMPTY(20001, \"上传的文件不能为空！\"), FILE_UPLOAD_ERROR(20002, \"文件上传失败！\"); /** * 状态码 */ private Integer code; /** * 状态参数 */ private String msg; ResultEnum(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; // ..getter、setter..&#125; 为了封装统一的返回json格式，创建出R.java固定返回格式，之后凡是需要用到返回json的格式的情况，统一返回R对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class R &#123; /** * 状态码 */ private Integer code; /** * 状态数据 */ private String msg; /** * 数据 */ private Object data; public R() &#123; &#125; private R(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; private R(Integer code, String msg, Object data) &#123; this.code = code; this.msg = msg; this.data = data; &#125; public static R create(Integer code, String msg) &#123; return new R(code, msg); &#125; public static R create(Integer code, String msg, Object data) &#123; return new R(code, msg, data); &#125; public static R create(ResultEnum re) &#123; return new R(re.getCode(), re.getMsg()); &#125; public static R create(ResultEnum re, Object data) &#123; return new R(re.getCode(), re.getMsg(), data); &#125; // ..getter、setter..&#125; 封装统一的自定义异常对象，这样就可以在统一的Controller中统一处理异常 12345678910111213141516171819202122public class CustomizedException extends RuntimeException &#123; private Integer code; public CustomizedException(Integer code, String message) &#123; super(message); this.code = code; &#125; public CustomizedException(ResultEnum re)&#123; super(re.getMsg()); this.code = re.getCode(); &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125;&#125; 统一的异常处理类MyExceptionHandler处理所有的自定义异常和其他异常，返回给前端以统一的格式 1234567891011121314151617181920212223@RestControllerAdvicepublic class MyExceptionHandler &#123; /** * 处理用户异常 * @param e 自定义异常异常 */ @ExceptionHandler(CustomizedException.class) public R handleUserException(CustomizedException e) &#123; // 封装异常信息成R return R.create(e.getCode(), e.getMessage()); &#125; /** * 通用异常处理方法 * @return */ @ExceptionHandler(Exception.class) public R handleException() &#123; //返回服务器内部错误 return R.create(ResultEnum.INNER_ERROR); &#125;&#125; 用户管理用户登录检测用户登录和注册功能很简单，不细说。 重点说一下登录拦截的实现，因为权限管理的框架暂时还没有学到，暂时使用Spring AOP简单实现用户的登录与否的验证： 如果没有登录的情况下，只能访问部分接口，访问受保护的接口全部重定向到登录界面 @Pointcut注解指定了一个切面表达式，在切面表达式中使用within指定了只对外暴露LoginController中的接口，而保护所有的其他Controller中定义的接口 切面中定义了一个环绕通知，在环绕通知中检查session中是否存在了用户名，是就放行，否则强制跳转到登录界面 1234567891011121314151617181920212223242526@Aspect@Componentpublic class LoginInterceptor &#123; private final Logger log = LoggerFactory.getLogger(LoginInterceptor.class); @Pointcut(\"within(com.hitopo.controller..*) &amp;&amp; !within(com.hitopo.controller.LoginController)\") public void pointcut() &#123; &#125; @Around(\"pointcut()\") public Object trackInfo(ProceedingJoinPoint joinPoint) throws Throwable &#123; ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); String username = (String) request.getSession().getAttribute(\"username\"); if (username == null) &#123; log.info(\"***************用户未登录***************\"); // 跳转到登录界面 attributes.getResponse().sendRedirect(request.getContextPath() + \"/login\"); &#125; else &#123; log.info(\"***************用户已登录***************\"); &#125; // 这里一定要返回，否则会导致404错误 return joinPoint.proceed(); &#125;&#125; 商品管理商品文件上传管理商品管理部分大多是一些增删改查的最基本的功能， 不细说，重点说一下文件上传功能 思路分析图片文件的上传和表单提交是两个功能，对应不同的接口，一般来说，前端表单中的控件中绑定的数据也不会是整个图片，而是图片的url访问地址 图片的上传时机？ 图片应该在前端点击文件上传并且选择了要上传的文件之后就调用后端接口上传文件，然后提交表单的时候再调用另一个后端接口提交数据，此时图片文件部分在表单中的表现形式就是url地址 如何获得已经上传的图片的url地址？ 前端：像本项目中使用的ElementUI中文件组件中有on-success回调函数，一旦上传成功之后就会调用该函数，可以在这个回调函数中获取后端返回的图片url地址绑定到数据中 后端：后端负责接收到用户上传的文件，保存到自己的文件服务器上或者调用第三方服务，保存到第三方的云中，返回图片的url地址 图片的回显回显图片很简单，只需要在数据库中保存了正确图片url访问地址，在前端的table控件中使用&lt;img src=&#39;图片url&#39;/&gt;即可显示图片 前端实现html12345678910111213 &lt;el-upload ref=\"upload\" action=\"/simple-shop/upload\" multiple name=\"picture\" list-type=\"picture-card\" :limit=\"1\" :on-exceed=\"onExceed\" :file-list=\"fileList\" :before-upload=\"beforeUpload\" :on-success=\"handleSuccess\" :on-remove=\"handleRemove\"&gt;&lt;/el-upload&gt; 本项目中使用的是ElementUI中的el-upload控件，完全的控件使用方法见官方文档 这里简单介绍下项目中用到的参数 ref：vue原生参数，用来给组件注册引入信息。引用信息会传递到父组件的$refs对象上。 action：文件上传的后端接口 name：文件上传的文件字段名 :limit：最大允许上传文件个数 list-type：ElementUI文件上传插件类型 on-exceed：文件个数超过个数的钩子函数 :fileList：上传的文件列表，这个参数在上传组件中回显图片，包含两个参数，name和url，在表单控件中想要显示图片，给这两个参数赋值即可 :beforeUpload：文件上传前的钩子函数 :on-success：文件上传成功之后的钩子函数 :on-remove：移除文件的钩子函数 js123456789101112131415161718192021222324252627282930313233343536373839404142//文件上传成功的钩子函数 handleSuccess(res, file, fileList) &#123; this.$message(&#123; type: 'info', message: '图片上传成功', duration: 6000 &#125;); this.editor.imageUrl = file.response.data.url; //将返回的图片访问url地址赋值imageUrl字段 console.log(this.editor.imageUrl); &#125;, //删除文件之前的钩子函数 handleRemove(file, fileList) &#123; this.$message(&#123; type: 'info', message: '已删除原有图片', duration: 6000 &#125;); &#125;, //上传的文件个数超出设定时触发的函数 onExceed(files, fileList) &#123; this.$message(&#123; type: 'info', message: '最多只能上传一个图片', duration: 6000 &#125;); &#125;, //参数是上传的文件，若返回false，或返回Primary且被reject，则停止上传 beforeUpload(file) &#123; const isJPG = file.type === 'image/jpeg'; const isGIF = file.type === 'image/gif'; const isPNG = file.type === 'image/png'; const isBMP = file.type === 'image/bmp'; const isLt2M = file.size / 1024 / 1024 &lt; 2; if (!isJPG &amp;&amp; !isGIF &amp;&amp; !isPNG &amp;&amp; !isBMP) &#123; this.$message.error('上传图片必须是JPG/GIF/PNG/BMP 格式!'); &#125; if (!isLt2M) &#123; this.$message.error('上传图片大小不能超过 2MB!'); &#125; return (isJPG || isBMP || isGIF || isPNG) &amp;&amp; isLt2M; &#125; 从上面的js代码中可以看到一般在文件上传之前限制等待上传的文件的类型和大小，在文件上传完成之后赋值绑定文件的url，从而达到回显图片的效果。 需要注意的是，该空间上传文件的时候并不需要设置form表单的类型是multipart/form-data 控件会自动帮我们设置请求类型为POST，表单类型是multipart/form-data 服务器返回的json是：可以看到data属性中封装了图片的访问地址 后端Controller单独提取出了一个UploadController用来处理文件上传的参数 123456789101112131415@RestControllerpublic class UploadController &#123; @Autowired private UploadService uploadService; /** * 上传文件 */ @PostMapping(\"/upload\") public R upload(@RequestParam(\"picture\") MultipartFile picFile) &#123; String urlPrefix = \"http://127.0.0.1:8080/simple-shop\"; return uploadService.upload(picFile, urlPrefix); &#125;&#125; service1234567891011121314151617181920212223public R upload(MultipartFile picFile, String urlPrefix) &#123; // 为了放置文件名重复，重新设置文件名 String originalFileName = picFile.getOriginalFilename(); // 文件类型 String type = originalFileName.substring(originalFileName.lastIndexOf(\".\") + 1); // 生成新的文件名 LocalDateTime dateTime = LocalDateTime.now(); DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyyMMddHHmmss\"); String fileName = dateTime.format(formatter) + \".\" + type; String uploadPath; try &#123; // 上传文件 uploadPath = FileUploadUtil.upload(picFile.getInputStream(), \"images/\", fileName); &#125; catch (IOException e) &#123; throw new CustomizedException(ResultEnum.FILE_UPLOAD_ERROR); &#125; // uploadPath:/upload/image/test.jpg // 组装访问路径 String url = urlPrefix + uploadPath; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"url\", url); return R.create(ResultEnum.CREATED, map); &#125; 文件上传工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class FileUploadUtil &#123; /** * 绝对路径 **/ private static String absolutePath = \"\"; /** * 静态目录 **/ private static String staticDir = \"static\"; /** * 文件存放的目录 **/ private static String fileDir = \"/upload/\"; /** * 上传单个文件 * 最后文件存放路径为：static/upload/image/test.jpg * 文件访问路径为：http://127.0.0.1:8080/upload/image/test.jpg * 该方法返回值为：/upload/image/test.jpg * @param inputStream 文件流 * @param path 文件路径，如：image/ * @param filename 文件名，如：test.jpg * @return 成功：上传后的文件访问路径，失败返回：null */ public static String upload(InputStream inputStream, String path, String filename) throws IOException &#123; //第一次会创建文件夹 createDirIfNotExists(); String resultPath = fileDir + path + filename; //存文件 File uploadFile = new File(absolutePath, staticDir + resultPath); FileUtils.copyInputStreamToFile(inputStream, uploadFile); return resultPath; &#125; /** * 创建文件夹路径 */ private static void createDirIfNotExists() &#123; if (!absolutePath.isEmpty()) &#123; return; &#125; //获取跟目录 File file = null; try &#123; file = new File(ResourceUtils.getURL(\"classpath:\").getPath()); &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(\"获取根目录失败，无法创建上传目录！\"); &#125; if (!file.exists()) &#123; file = new File(\"\"); &#125; absolutePath = file.getAbsolutePath(); File upload = new File(absolutePath, staticDir + fileDir); if (!upload.exists()) &#123; upload.mkdirs(); &#125; &#125; /** * 删除文件 * @param path 文件访问的路径upload开始 如： /upload/image/test.jpg * @return true 删除成功； false 删除失败 */ public static boolean delete(String path) &#123; File file = new File(absolutePath, staticDir + path); if (file.exists()) &#123; return file.delete(); &#125; return false; &#125;&#125; 由于springboot使用的是嵌入式tomcat，所以获取到的项目地址每次启动都不相同，所以不能用request.getSession().getServletContext().getRealPath(&quot;/upload&quot;)获取地址 ResourceUtils.getURL(&quot;classpath:&quot;).getPath()是关键，可以获得maven项目的项目的类路径， 当然存储文件的地址也可以设置为本地磁盘的其他绝对路径。","categories":[],"tags":[]},{"title":"Mybatis-Plus插件的简单使用","slug":"Mybatis-Plus插件的简单使用","date":"2020-04-18T10:38:29.000Z","updated":"2020-04-18T10:45:05.101Z","comments":true,"path":"2020/04/18/Mybatis-Plus插件的简单使用/","link":"","permalink":"http://yoursite.com/2020/04/18/Mybatis-Plus%E6%8F%92%E4%BB%B6%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"MyBatis-Plus简介Mybatis-plus本质上是Mybatis的增强插件，为了简化开发和提高开发效率而生 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询","text":"MyBatis-Plus简介Mybatis-plus本质上是Mybatis的增强插件，为了简化开发和提高开发效率而生 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 SpringBoot集成配置数据库配置准备好数据库中的表和测试数据 12345678910111213141516171819202122232425262728293031# 创建数据表DROP TABLE IF EXISTS `mp_employee`;CREATE TABLE `mp_employee`( `id` bigint(20) NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '主键', `last_name` varchar(50) COMMENT '名称', `email` varchar(50) COMMENT 'Email邮箱', `gender` char(1) COMMENT '性别：0-男，1-女', `age` int) ENGINE = InnoDB DEFAULT CHARSET = utf8;# 插入测试数据INSERT INTO mp_employee(last_name, email, gender, age)VALUES ('Tom', 'tom@qq.com', 0, 22);INSERT INTO mp_employee(last_name, email, gender, age)VALUES ('James', 'james@qq.com', 0, 18);INSERT INTO mp_employee(last_name, email, gender, age)VALUES ('july', 'july@qq.com', 1, 29);INSERT INTO mp_employee(last_name, email, gender, age)VALUES ('jane', 'jane@qq.com', 1, 16);INSERT INTO mp_employee(last_name, email, gender, age)VALUES ('black', 'black@qq.com', 0, 25);INSERT INTO mp_employee(last_name, email, gender, age)VALUES ('white', 'white@qq.com', 1, 24); 创建对应的JavaBean在com.hitopop.entity包中创建实体类Employee.java 123456789101112131415161718192021222324252627282930@Data@TableName(\"mp_employee\")public class Employee &#123; /** * 主键 */ @TableId(type = IdType.AUTO) private Long id; /** * 名称 */ @TableField(\"last_name\") private String lastName; /** * Email邮箱 */ private String email; /** * 性别：0-男，1-女 */ private String gender; /** * 名称 */ private Integer age;&#125; @TableName指定了实体类对应的数据库表名 @TableId指引属性为数据库的主键，而且指定了type为auto自增加，Mybatis-Plus会为我们自动将插入数据库的主键注入到对象中去 @TableFiled是用在当数据库的字段名和Java实体类字段名称不同时用来对应的 引入依赖pom.xml中引入Mybatis-plus插件的相关依赖，除了需要的配置之外，还需要lombok和mysql连接等依赖 12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 引入mybatis-plus-boot-starter之外不需要再单独引入Mybatis和Mybatis和spring的整合包了，mybatis-plus帮我们管理了这些依赖 添加配置application.yml中配置数据源等信息 12345678910spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver username: root password: root url: jdbc:mysql://127.0.0.1:3306/springboot-mybatis?characterEncoding=utf8&amp;useUnicode=true&amp;serverTimeZone=Asia/Shanghai mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 上次已经说过了，要使用最新的com.mysql.cj.jdbc.Driver驱动器 log-impl配置是为了在控制台中看到sql语句 插件通用配置在application.yml中可以配置很多和插件有关的信息 常见的有： 12345678910111213mybatis-plus: # 输出sql语句 configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # sql映射文件位置 mapper-locations: classpath:mapper/**/*.xml # 全局数据配置 global-config: db-config: # 数据表的主键生成策略 id-type: auto # 表的前缀 table-prefix: tb_ 通用CRUD操作此时我们已经有了mp_empolyee表，如果想要使用最基本的CRUD操作，以前使用Mybatis时我们是怎么做的呢？ 编写EmployeeMapper接口，在接口中定义Dao层的接口 编写EmployeeMapper接口对应的EmployeeMapper.xml文件，手动编写接口中定义的sql语句 当程序中的实体类越来越多的时候就会发现这样对每个表的最简单的CRUD操作都手动写sql语句是很累的一件事。 编写接口基于Mybatis-Plus，我们如果只需要最简单的CRUD操作，我们只需要在创建出的Mapper接口中继承BaseMapper接口即可获得基本的CRUD方法 在com.hitopo.mapper中创建出EmployeeMapper.java接口 12public interface EmployeeMapper extends BaseMapper&lt;Employee&gt; &#123;&#125; 这个接口中并不需要有任何方法，所有的简单CRUD操作全部都在BaseMapper中存在了，当然，如果你想要有一些自定义的方法，也可以在该接口中定义 基本配置写好接口类之后需要让spring帮我们管理这个接口，只需要在Application.java的主启动类上面添加@MapperScan注解扫描接口类 123456789@SpringBootApplication@MapperScan(\"com.hitopo.mapper\")public class SpringbootMybatisPlusApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootMybatisPlusApplication.class, args); &#125;&#125; 测试查询1234567891011121314151617181920212223242526272829303132333435@Testpublic void testSelect() &#123; // 根据主键查询单个对象 Employee employee = employeeMapper.selectById(3L); log.info(\"selectById(),employee=&#123;&#125;\", employee); log.info(\"--------------------\"); // 查询所有列表 List&lt;Employee&gt; employeeList1 = employeeMapper.selectList(null); log.info(\"selectList(),employeeList1=&#123;&#125;\", employeeList1); log.info(\"--------------------\"); //查询所有指定id的数据 List&lt;Long&gt; ids = new ArrayList&lt;&gt;(); ids.add(2L); ids.add(3L); ids.add(5L); List&lt;Employee&gt; employeeList2 = employeeMapper.selectBatchIds(ids); log.info(\"selectBatchIds(),employeeList2=&#123;&#125;\", employeeList2); log.info(\"--------------------\"); // 查询单个记录 // 如果查询出来的不是一条记录会报错 Employee tom = employeeMapper.selectOne(new QueryWrapper&lt;Employee&gt;().eq(\"last_name\", \"Tom\")); log.info(\"selectOne(),employee=&#123;&#125;\", tom); log.info(\"--------------------\"); // 根据条件查询，条件封装在Map中 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"last_name\", \"James\"); map.put(\"age\", 18); List&lt;Employee&gt; james = employeeMapper.selectByMap(map); log.info(\"selectByMap(),employee=&#123;&#125;\", james); log.info(\"--------------------\");&#125; 上面的查询操作中很多时候需要查询参数时可以使用selectByMap，但是Map的只能封装相等条件，后面会说如何封装查询参数 保存1234567891011@Testpublic void testSave() &#123; // 待保存的记录，注意此时没有创建主键和email属性 Employee employee = new Employee(); employee.setLastName(\"张三\"); employee.setAge(12); employee.setGender(\"1\"); int result = employeeMapper.insert(employee); log.info(\"保存成功，受影响的行数是：&#123;&#125;\", result); log.info(\"employee.getId():&#123;&#125;\", employee.getId());&#125; insert只有一个方法，在实体类中配置主键的类型是idType.auto之后插入数据库之后，Mybatis-Plus插件会自动帮我们回写id属性到employee对象中， 观察sql语句，发现保存的employee中属性为null的的email发送的sql语句中并没有包括，这就是动态的特性 这里又引入了一个话题：既然插件是用null来帮我们判断是否需要插入某个字段，那么在实体类中最好不要使用基本数据类型，如int，boolean等，因为它们存在默认值，int的默认值是0，boolean的默认值的false。 应该使用它们的包装类Integer和Boolean，它们默认值就是null。基本数据类型没有赋值也会存在值，插件不好判断到底该属性是实际存在还是本来就是默认值不应该存在，导致歧义。 更新12345678910@Testpublic void testUpdate() &#123; Employee employee = new Employee(); employee.setId(7L); employee.setLastName(\"李四\"); employee.setGender(\"0\"); employee.setEmail(\"123@gmail.com\"); int result = employeeMapper.updateById(employee); log.info(\"受影响的行数是：&#123;&#125;\", result);&#125; 同理，根据id更新记录时候，不存在employee对象中的属性age在发送的更新的sql语句中不会存在，该函数返回值同样是受影响的行数 删除123456789101112@Testpublic void testDelete() &#123; int result1 = employeeMapper.deleteById(6L); int result2 = employeeMapper.deleteBatchIds(Arrays.asList(2L, 4L)); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"age\", 12); int result3 = employeeMapper.deleteByMap(map); log.info(\"deleteById()受影响的行数:&#123;&#125;\", result1); log.info(\"deleteBatchIds()受影响的行数:&#123;&#125;\", result2); log.info(\"deleteByMap()受影响的行数:&#123;&#125;\", result3);&#125; 总结以上还有一些方法没有列出测试是因为它们都是用了条件查询对象QueryWrapper作为参数传递，统一放到下一章节，从上面简单的CRUD操作中就可以看出，我们不需要手写任何的sql语句就可以实现简单的CRUD操作，实在是方便。 条件构造器 QueryWrapper(LambdaQueryWrapper) 和 UpdateWrapper(LambdaUpdateWrapper) 的父类用于生成 sql 的 where 条件, entity 属性也用于生成 sql 的 where 条件注意: entity 生成的 where 条件与 使用各个 api 生成的 where 条件没有任何关联行为 查询方式 说明 allEq 基于map的= eq 等于 ne 不等于 gt 大于 lt 小于 ge 大于等于 le 小于等于 between 在某两个数的区间内 notBetween 不在某两个值的区间内 like 模糊匹配 not like 模糊匹配 in 在某个区间内 groupBy 分组 orderBy 排序 or 或者 and 且 apply 在sql语句最后拼接（可能有sql注入的风险） 以上就是常见的一些方法，还有一些没有列出，可以看官方文档 https://mp.baomidou.com/guide/wrapper.html#service-java 使用上述的方法就是在需要使用QueryWrapper或者UpdateWrapper的时候使用new QueryWrapper&lt;&gt;().eq().ne().groupBy()这样 整合测试1234567891011121314151617@Testpublic void testConditionalOps() &#123; // 条件查询 List&lt;Employee&gt; list = employeeMapper.selectList(new QueryWrapper&lt;Employee&gt;().between(\"age\", 12, 25)); log.info(\"selectList()，年龄在12-25的职工列表：&#123;&#125;\", list); // 条件删除 int result = employeeMapper.delete(new QueryWrapper&lt;Employee&gt;().eq(\"last_name\", \"张三\")); log.info(\"delete(),删除lastname是张三的记录\"); // 条件修改 Employee employee = new Employee(); employee.setAge(20); employeeMapper.update(employee, new UpdateWrapper&lt;Employee&gt;().like(\"email\", \"@qq.com\")); log.info(\"update(),修改email中包含@qq.com字符串的记录的年龄为20\");&#125; 插件分页插件只需要在spring容器中注入PaginationInterceptor，对paginationInterceptor进行配置即可使用 在com.hitopo.config中创建MybatisPlusConfig.java 123456789101112131415@Configurationpublic class MybatisPlusConfig &#123; @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor interceptor = new PaginationInterceptor(); // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false // paginationInterceptor.setOverflow(false); // 设置最大单页限制数量，默认 500 条，-1 不受限制 interceptor.setLimit(500); // 开启 count 的 join 优化,只针对部分 left join interceptor.setCountSqlParser(new JsqlParserCountOptimize(true)); return interceptor; &#125;&#125; 这样之后使用selectPage方法就可以实现分页的效果了 123456789@Testpublic void testPage() &#123; IPage&lt;Employee&gt; iPage = employeeMapper.selectPage(new Page&lt;&gt;(2, 3), null); log.info(\"数据：&#123;&#125;\", iPage.getRecords()); log.info(\"当前页：&#123;&#125;\", iPage.getCurrent()); log.info(\"页的大小：&#123;&#125;\", iPage.getSize()); log.info(\"总页数：&#123;&#125;\", iPage.getPages()); log.info(\"总记录数：&#123;&#125;\", iPage.getTotal());&#125; 代码生成工具AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。 AutoGenerator提供了大量自定义设置，生成的代码都是基于Java代码来生成的 添加依赖MyBatis-Plus 从 3.0.3 之后移除了代码生成器与模板引擎的默认依赖，需要手动添加相关依赖： 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--模板引擎--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt; 配置生成器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Testpublic void testGenerator() &#123; // 创建代码生成器 AutoGenerator generator = new AutoGenerator(); // 全局配置 GlobalConfig globalConfig = new GlobalConfig(); globalConfig.setActiveRecord(true) // 支持AR模式 .setAuthor(\"hitopo\") // 设置作者 .setOutputDir(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\springboot-learn\\\\springboot-mybatis-plus\\\\src\\\\main\\\\java\") // 输出主目录 .setFileOverride(true) // 覆盖文件 .setIdType(IdType.AUTO) // 主键类型 .setServiceName(\"%sService\") // 生成的service名称，默认是IEmployeeService，这样改成EmployeeService .setBaseResultMap(true) // 设置XML文件中生成基本的ResultMap .setBaseColumnList(true); // 设置生成sql片段 generator.setGlobalConfig(globalConfig); // 数据源配置 DataSourceConfig dataSourceConfig = new DataSourceConfig(); dataSourceConfig.setDbType(DbType.MYSQL) .setDriverName(\"com.mysql.cj.jdbc.Driver\") .setUsername(\"root\") .setPassword(\"root\") .setUrl(\"jdbc:mysql://127.0.0.1:3306/springboot-mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai\"); generator.setDataSource(dataSourceConfig); // 策略配置 StrategyConfig strategyConfig = new StrategyConfig(); strategyConfig.setCapitalMode(true) // 全局大写命名 .setNaming(NamingStrategy.underline_to_camel) // 数据库表映射到实体的命名策略 .setTablePrefix(\"mp_\") // 表的前缀 .setInclude(\"mp_employee\"); // 设置需要生成的表 generator.setStrategy(strategyConfig); // 包名的生成配置 PackageConfig packageConfig = new PackageConfig(); packageConfig.setParent(\"com.hitopo.mpg\") // 父包名 .setMapper(\"mapper\") // Dao层包名 .setService(\"service\") // service层包名 .setController(\"controller\") // controller层包名 .setEntity(\"beans\") // 实体类包名 .setXml(\"mapper\"); // 映射文件位置 generator.setPackageInfo(packageConfig); // 执行生成器 generator.execute();&#125; 此时运行该测试，会在指定的位置生成自动生成的代码： 这里生成的EmpolyeeServiceImpl继承了ServiceImpl 在ServiceImpl中已经完成了Mapper对象的注入，直接在EmpolyeeServiceImpl中使用baseMapper即可，不需要自己再进行注入 在ServiceImpl中也帮我们提供了常用的CRUD方法，基本的CRUD在Service中也不需要再自己写方法 逻辑删除配置更改 123456mybatis-plus: global-config: db-config: logic-delete-field: flag #全局逻辑删除字段值 3.3.0开始支持，详情看下面。 logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) 局部配置：实体类的字段上添加@TableLogic注解，此方式会覆盖全局配置，如果没有注解，则会默认使用全局配置 注意： 配置逻辑删除之后，再使用Mybatis-Plus提供的删除和查询功能都会自动带上逻辑存在的字符。 也就是说，查询没有添加条件时默认只能查询到未删除记录，删除也转变成了Update语句，如果想要得到所有的记录或者想要拿到逻辑上删除的字段，只能自己写sql语句。","categories":[],"tags":[]},{"title":"Spring整合Mybatis","slug":"Spring整合Mybatis","date":"2020-04-18T10:33:31.000Z","updated":"2020-04-18T10:36:55.270Z","comments":true,"path":"2020/04/18/Spring整合Mybatis/","link":"","permalink":"http://yoursite.com/2020/04/18/Spring%E6%95%B4%E5%90%88Mybatis/","excerpt":"Spring Boot整合MybatisMybatis是一个轻量级的ORM框架，SpringBoot是最近比较流行的框架，这两者的整合同样很简单 准备准备数据表1234567891011121314151617181920212223-- create database springboot_mybatis charset utf8;DROP TABLE IF EXISTS `user`;CREATE TABLE `user`( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `username` varchar(255) DEFAULT NULL COMMENT '用户名', `password` varchar(255) DEFAULT NULL COMMENT '密码', `create_time` date DEFAULT NULL COMMENT '创建日期', PRIMARY KEY (`id`)) ENGINE = InnoDB AUTO_INCREMENT = 5 DEFAULT CHARSET = utf8;INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (5, '张三', '123', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (6, '李四', 'admin', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (7, '王五', 'root', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (8, '赵六', 'adm', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (9, 'admin', '123', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (10, 'root', '3333', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (11, 'user', '2333', '2020-04-08');","text":"Spring Boot整合MybatisMybatis是一个轻量级的ORM框架，SpringBoot是最近比较流行的框架，这两者的整合同样很简单 准备准备数据表1234567891011121314151617181920212223-- create database springboot_mybatis charset utf8;DROP TABLE IF EXISTS `user`;CREATE TABLE `user`( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `username` varchar(255) DEFAULT NULL COMMENT '用户名', `password` varchar(255) DEFAULT NULL COMMENT '密码', `create_time` date DEFAULT NULL COMMENT '创建日期', PRIMARY KEY (`id`)) ENGINE = InnoDB AUTO_INCREMENT = 5 DEFAULT CHARSET = utf8;INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (5, '张三', '123', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (6, '李四', 'admin', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (7, '王五', 'root', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (8, '赵六', 'adm', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (9, 'admin', '123', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (10, 'root', '3333', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (11, 'user', '2333', '2020-04-08'); 引入依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 配置参数在application.yml中配置相关信息 123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver username: root password: root url: jdbc:mysql://127.0.0.1/springboot-mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai 需要注意的是driver-class-name新版的写法是com.mysql.cj.jdbc.Driver，而且在url中除了指定useUnicode和charavterEncoding之外，在SpringBoot2.0之后还必须指定serverTimeZone，否则会报错 程序中使用基本配置 之前在SSM开发时，会在MapperScannerConfigurer中配置：&lt;property name=&quot;basePackage&quot; value=&quot;xxx.mapper&quot;/&gt;用于使用Mybatis的接口代理开发模式（且接口和XML需要名称相同）。那么在SpringBoot整合Mybatis中也要有对应的配置： 方式一：在每个interface Mapper前添加@Mapper注解 方式二：在Application.java启动类前添加@MapperScan(&quot;cn.tycoding.mapper&quot;)注解 推荐使用第二种，这种包扫描的方式简化了在每个Mapper类中去配置注解 注解的方式Mybatis提供了一些注解实现快速CRUD，比如：@Select,@Update,@Insert,@Delete CRUD创建Entity实体类 com.hitopo.entity中创建User实体类User.java 1234567@Datapublic class User &#123; private Long id; private String username; private String password; private LocalDateTime createTime;&#125; 创建注解版的Mapper com.hitopo.mapper中创建UserMapperAno.java 12345678910111213141516171819202122public interface UserMapperAno &#123; @Select(\"SELECT * FROM user\") @Results(&#123; @Result(property = \"createTime\", column = \"create_time\") &#125;) List&lt;User&gt; findAll(); @Select(\"SELECT * FROM user WHERE id = #&#123;id&#125;\") @Results(&#123; @Result(property = \"createTime\", column = \"create_time\") &#125;) User findOneById(Long id); @Insert(\"INSERT INTO user(username, password, create_time) VALUES (#&#123;username&#125;,#&#123;password&#125;,#&#123;createTime&#125;)\") void save(User user); @Update(\"UPDATE user SET username=#&#123;username&#125;,password=#&#123;password&#125; WHERE id = #&#123;id&#125;\") void update(User user); @Delete(\"DELETE FROM user WHERE id = #&#123;id&#125;\") void delete(Long id);&#125; 当数据库中的字段和Java中的字段的名称不同时，使用@Result来指定如何绑定属性 测试编写测试类test/com/hitopo/mapper/UserMapperAnoTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@SpringBootTest@RunWith(SpringRunner.class)public class UserMapperAnoTest &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private UserMapperAno userMapperAno; @Test public void testFindAll() &#123; List&lt;User&gt; userList = userMapperAno.findAll(); userList.forEach(user -&gt; logger.info(\"userList=&#123;&#125;\", user)); &#125; @Test public void testFindOneById() &#123; User user = userMapperAno.findOneById(9L); logger.info(\"user=&#123;&#125;\", user); &#125; @Test public void testSave()&#123; User user = new User(); user.setUsername(\"测试用户\"); user.setPassword(\"123\"); user.setCreateTime(LocalDate.of(2010, 11, 23)); userMapperAno.save(user); testFindAll(); &#125; @Test public void testUpdate()&#123; User user = new User(); user.setId(8L); user.setUsername(\"测试用户2\"); user.setPassword(\"123444\"); user.setCreateTime(LocalDate.of(2010, 11, 23)); userMapperAno.update(user); testFindAll(); &#125; @Test public void testDelete()&#123; userMapperAno.delete(7L); testFindAll(); &#125;&#125; XML配置文件的方式基于XML配置文件的方式和基本相同，和注解版最大的不同就是Dao层，XML版会自动根据Dao层接口的方法名自动映射到XML中同名id对应的SQL 配置修改在application.yml配置文件中添加Mybatis的配置 123456789#mybatis配置mybatis: mapper-locations: classpath:mapper/**/*.xml type-aliases-package: cn.tycoding.entity configuration: # 使用jdbc的getGeneratedKeys 可以获取数据库自增主键值 use-generated-keys: true # 开启驼峰命名转换，如：Table(create_time) -&gt; Entity(createTime)。不需要我们关心怎么进行字段匹配，mybatis会自动识别`大写字母与下划线` map-underscore-to-camel-case: true CRUDcom.hitopo.mapper包内创建UserMapperXML.java 123456789101112public interface UserMapper &#123; List&lt;User&gt; findAll(); User findOneById(Long id); void save(User user); void update(User user); void delete(Long id);&#125; 在配置文件指定的mapper配置文件目录resources/mapper中创建UserMapper.xml文件 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.hitopo.mapper.UserMapperXML\"&gt; &lt;select id=\"findAll\" resultType=\"com.hitopo.entity.User\"&gt; SELECT * FROM user &lt;/select&gt; &lt;select id=\"findOneById\" resultType=\"com.hitopo.entity.User\"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;insert id=\"save\" parameterType=\"com.hitopo.entity.User\"&gt; INSERT INTO user(username, password, create_time) VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;createTime&#125;) &lt;/insert&gt; &lt;update id=\"update\" parameterType=\"com.hitopo.entity.User\"&gt; UPDATE user SET username=#&#123;username&#125;, password=#&#123;password&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; &lt;delete id=\"delete\" parameterType=\"long\"&gt; DELETE FROM user WHERE id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@SpringBootTest@RunWith(SpringRunner.class)public class UserMapperXMLTest &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private UserMapperXML userMapperXML; @Test public void testFindAll() &#123; List&lt;User&gt; userList = userMapperXML.findAll(); userList.forEach(user -&gt; logger.info(\"userList=&#123;&#125;\", user)); &#125; @Test public void testFindOneById() &#123; User user = userMapperXML.findOneById(9L); logger.info(\"user=&#123;&#125;\", user); &#125; @Test public void testSave() &#123; User user = new User(); user.setUsername(\"测试用户\"); user.setPassword(\"123\"); user.setCreateTime(LocalDate.of(2010, 11, 23)); userMapperXML.save(user); testFindAll(); &#125; @Test public void testUpdate() &#123; User user = new User(); user.setId(8L); user.setUsername(\"测试用户2\"); user.setPassword(\"123444\"); user.setCreateTime(LocalDate.of(2010, 11, 23)); userMapperXML.update(user); testFindAll(); &#125; @Test public void testDelete() &#123; userMapperXML.delete(7L); testFindAll(); &#125;&#125; 结束语Mybatis的基于注解和基于XML文件的配置方式集成到SpringBoot中都很简单，至于选择哪个方法比较好，我认为，简单的CRUD操作可以直接用注解生成，简单快捷。而复杂的动态sql和多表联结查询之类的最好放在XML文件中，方便统一管理","categories":[],"tags":[]}],"categories":[],"tags":[]}