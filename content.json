{"meta":{"title":"Hitopo's Blog","subtitle":"Start from this moment.","description":"","author":"Hitopo","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-04-03T03:39:31.000Z","updated":"2020-04-03T03:43:14.160Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这就是我，是颜色不一样的烟火！"},{"title":"categories","date":"2020-04-03T04:00:55.000Z","updated":"2020-04-03T04:00:56.016Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Mybatis-Plus插件的简单使用","slug":"Mybatis-Plus插件的简单使用","date":"2020-04-18T10:38:29.000Z","updated":"2020-04-18T10:45:05.101Z","comments":true,"path":"2020/04/18/Mybatis-Plus插件的简单使用/","link":"","permalink":"http://yoursite.com/2020/04/18/Mybatis-Plus%E6%8F%92%E4%BB%B6%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"MyBatis-Plus简介Mybatis-plus本质上是Mybatis的增强插件，为了简化开发和提高开发效率而生 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询","text":"MyBatis-Plus简介Mybatis-plus本质上是Mybatis的增强插件，为了简化开发和提高开发效率而生 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 SpringBoot集成配置数据库配置准备好数据库中的表和测试数据 12345678910111213141516171819202122232425262728293031# 创建数据表DROP TABLE IF EXISTS `mp_employee`;CREATE TABLE `mp_employee`( `id` bigint(20) NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '主键', `last_name` varchar(50) COMMENT '名称', `email` varchar(50) COMMENT 'Email邮箱', `gender` char(1) COMMENT '性别：0-男，1-女', `age` int) ENGINE = InnoDB DEFAULT CHARSET = utf8;# 插入测试数据INSERT INTO mp_employee(last_name, email, gender, age)VALUES ('Tom', 'tom@qq.com', 0, 22);INSERT INTO mp_employee(last_name, email, gender, age)VALUES ('James', 'james@qq.com', 0, 18);INSERT INTO mp_employee(last_name, email, gender, age)VALUES ('july', 'july@qq.com', 1, 29);INSERT INTO mp_employee(last_name, email, gender, age)VALUES ('jane', 'jane@qq.com', 1, 16);INSERT INTO mp_employee(last_name, email, gender, age)VALUES ('black', 'black@qq.com', 0, 25);INSERT INTO mp_employee(last_name, email, gender, age)VALUES ('white', 'white@qq.com', 1, 24); 创建对应的JavaBean在com.hitopop.entity包中创建实体类Employee.java 123456789101112131415161718192021222324252627282930@Data@TableName(\"mp_employee\")public class Employee &#123; /** * 主键 */ @TableId(type = IdType.AUTO) private Long id; /** * 名称 */ @TableField(\"last_name\") private String lastName; /** * Email邮箱 */ private String email; /** * 性别：0-男，1-女 */ private String gender; /** * 名称 */ private Integer age;&#125; @TableName指定了实体类对应的数据库表名 @TableId指引属性为数据库的主键，而且指定了type为auto自增加，Mybatis-Plus会为我们自动将插入数据库的主键注入到对象中去 @TableFiled是用在当数据库的字段名和Java实体类字段名称不同时用来对应的 引入依赖pom.xml中引入Mybatis-plus插件的相关依赖，除了需要的配置之外，还需要lombok和mysql连接等依赖 12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 引入mybatis-plus-boot-starter之外不需要再单独引入Mybatis和Mybatis和spring的整合包了，mybatis-plus帮我们管理了这些依赖 添加配置application.yml中配置数据源等信息 12345678910spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver username: root password: root url: jdbc:mysql://127.0.0.1:3306/springboot-mybatis?characterEncoding=utf8&amp;useUnicode=true&amp;serverTimeZone=Asia/Shanghai mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 上次已经说过了，要使用最新的com.mysql.cj.jdbc.Driver驱动器 log-impl配置是为了在控制台中看到sql语句 插件通用配置在application.yml中可以配置很多和插件有关的信息 常见的有： 12345678910111213mybatis-plus: # 输出sql语句 configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # sql映射文件位置 mapper-locations: classpath:mapper/**/*.xml # 全局数据配置 global-config: db-config: # 数据表的主键生成策略 id-type: auto # 表的前缀 table-prefix: tb_ 通用CRUD操作此时我们已经有了mp_empolyee表，如果想要使用最基本的CRUD操作，以前使用Mybatis时我们是怎么做的呢？ 编写EmployeeMapper接口，在接口中定义Dao层的接口 编写EmployeeMapper接口对应的EmployeeMapper.xml文件，手动编写接口中定义的sql语句 当程序中的实体类越来越多的时候就会发现这样对每个表的最简单的CRUD操作都手动写sql语句是很累的一件事。 编写接口基于Mybatis-Plus，我们如果只需要最简单的CRUD操作，我们只需要在创建出的Mapper接口中继承BaseMapper接口即可获得基本的CRUD方法 在com.hitopo.mapper中创建出EmployeeMapper.java接口 12public interface EmployeeMapper extends BaseMapper&lt;Employee&gt; &#123;&#125; 这个接口中并不需要有任何方法，所有的简单CRUD操作全部都在BaseMapper中存在了，当然，如果你想要有一些自定义的方法，也可以在该接口中定义 基本配置写好接口类之后需要让spring帮我们管理这个接口，只需要在Application.java的主启动类上面添加@MapperScan注解扫描接口类 123456789@SpringBootApplication@MapperScan(\"com.hitopo.mapper\")public class SpringbootMybatisPlusApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootMybatisPlusApplication.class, args); &#125;&#125; 测试查询1234567891011121314151617181920212223242526272829303132333435@Testpublic void testSelect() &#123; // 根据主键查询单个对象 Employee employee = employeeMapper.selectById(3L); log.info(\"selectById(),employee=&#123;&#125;\", employee); log.info(\"--------------------\"); // 查询所有列表 List&lt;Employee&gt; employeeList1 = employeeMapper.selectList(null); log.info(\"selectList(),employeeList1=&#123;&#125;\", employeeList1); log.info(\"--------------------\"); //查询所有指定id的数据 List&lt;Long&gt; ids = new ArrayList&lt;&gt;(); ids.add(2L); ids.add(3L); ids.add(5L); List&lt;Employee&gt; employeeList2 = employeeMapper.selectBatchIds(ids); log.info(\"selectBatchIds(),employeeList2=&#123;&#125;\", employeeList2); log.info(\"--------------------\"); // 查询单个记录 // 如果查询出来的不是一条记录会报错 Employee tom = employeeMapper.selectOne(new QueryWrapper&lt;Employee&gt;().eq(\"last_name\", \"Tom\")); log.info(\"selectOne(),employee=&#123;&#125;\", tom); log.info(\"--------------------\"); // 根据条件查询，条件封装在Map中 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"last_name\", \"James\"); map.put(\"age\", 18); List&lt;Employee&gt; james = employeeMapper.selectByMap(map); log.info(\"selectByMap(),employee=&#123;&#125;\", james); log.info(\"--------------------\");&#125; 上面的查询操作中很多时候需要查询参数时可以使用selectByMap，但是Map的只能封装相等条件，后面会说如何封装查询参数 保存1234567891011@Testpublic void testSave() &#123; // 待保存的记录，注意此时没有创建主键和email属性 Employee employee = new Employee(); employee.setLastName(\"张三\"); employee.setAge(12); employee.setGender(\"1\"); int result = employeeMapper.insert(employee); log.info(\"保存成功，受影响的行数是：&#123;&#125;\", result); log.info(\"employee.getId():&#123;&#125;\", employee.getId());&#125; insert只有一个方法，在实体类中配置主键的类型是idType.auto之后插入数据库之后，Mybatis-Plus插件会自动帮我们回写id属性到employee对象中， 观察sql语句，发现保存的employee中属性为null的的email发送的sql语句中并没有包括，这就是动态的特性 这里又引入了一个话题：既然插件是用null来帮我们判断是否需要插入某个字段，那么在实体类中最好不要使用基本数据类型，如int，boolean等，因为它们存在默认值，int的默认值是0，boolean的默认值的false。 应该使用它们的包装类Integer和Boolean，它们默认值就是null。基本数据类型没有赋值也会存在值，插件不好判断到底该属性是实际存在还是本来就是默认值不应该存在，导致歧义。 更新12345678910@Testpublic void testUpdate() &#123; Employee employee = new Employee(); employee.setId(7L); employee.setLastName(\"李四\"); employee.setGender(\"0\"); employee.setEmail(\"123@gmail.com\"); int result = employeeMapper.updateById(employee); log.info(\"受影响的行数是：&#123;&#125;\", result);&#125; 同理，根据id更新记录时候，不存在employee对象中的属性age在发送的更新的sql语句中不会存在，该函数返回值同样是受影响的行数 删除123456789101112@Testpublic void testDelete() &#123; int result1 = employeeMapper.deleteById(6L); int result2 = employeeMapper.deleteBatchIds(Arrays.asList(2L, 4L)); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"age\", 12); int result3 = employeeMapper.deleteByMap(map); log.info(\"deleteById()受影响的行数:&#123;&#125;\", result1); log.info(\"deleteBatchIds()受影响的行数:&#123;&#125;\", result2); log.info(\"deleteByMap()受影响的行数:&#123;&#125;\", result3);&#125; 总结以上还有一些方法没有列出测试是因为它们都是用了条件查询对象QueryWrapper作为参数传递，统一放到下一章节，从上面简单的CRUD操作中就可以看出，我们不需要手写任何的sql语句就可以实现简单的CRUD操作，实在是方便。 条件构造器 QueryWrapper(LambdaQueryWrapper) 和 UpdateWrapper(LambdaUpdateWrapper) 的父类用于生成 sql 的 where 条件, entity 属性也用于生成 sql 的 where 条件注意: entity 生成的 where 条件与 使用各个 api 生成的 where 条件没有任何关联行为 查询方式 说明 allEq 基于map的= eq 等于 ne 不等于 gt 大于 lt 小于 ge 大于等于 le 小于等于 between 在某两个数的区间内 notBetween 不在某两个值的区间内 like 模糊匹配 not like 模糊匹配 in 在某个区间内 groupBy 分组 orderBy 排序 or 或者 and 且 apply 在sql语句最后拼接（可能有sql注入的风险） 以上就是常见的一些方法，还有一些没有列出，可以看官方文档 https://mp.baomidou.com/guide/wrapper.html#service-java 使用上述的方法就是在需要使用QueryWrapper或者UpdateWrapper的时候使用new QueryWrapper&lt;&gt;().eq().ne().groupBy()这样 整合测试1234567891011121314151617@Testpublic void testConditionalOps() &#123; // 条件查询 List&lt;Employee&gt; list = employeeMapper.selectList(new QueryWrapper&lt;Employee&gt;().between(\"age\", 12, 25)); log.info(\"selectList()，年龄在12-25的职工列表：&#123;&#125;\", list); // 条件删除 int result = employeeMapper.delete(new QueryWrapper&lt;Employee&gt;().eq(\"last_name\", \"张三\")); log.info(\"delete(),删除lastname是张三的记录\"); // 条件修改 Employee employee = new Employee(); employee.setAge(20); employeeMapper.update(employee, new UpdateWrapper&lt;Employee&gt;().like(\"email\", \"@qq.com\")); log.info(\"update(),修改email中包含@qq.com字符串的记录的年龄为20\");&#125; 插件分页插件只需要在spring容器中注入PaginationInterceptor，对paginationInterceptor进行配置即可使用 在com.hitopo.config中创建MybatisPlusConfig.java 123456789101112131415@Configurationpublic class MybatisPlusConfig &#123; @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor interceptor = new PaginationInterceptor(); // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false // paginationInterceptor.setOverflow(false); // 设置最大单页限制数量，默认 500 条，-1 不受限制 interceptor.setLimit(500); // 开启 count 的 join 优化,只针对部分 left join interceptor.setCountSqlParser(new JsqlParserCountOptimize(true)); return interceptor; &#125;&#125; 这样之后使用selectPage方法就可以实现分页的效果了 123456789@Testpublic void testPage() &#123; IPage&lt;Employee&gt; iPage = employeeMapper.selectPage(new Page&lt;&gt;(2, 3), null); log.info(\"数据：&#123;&#125;\", iPage.getRecords()); log.info(\"当前页：&#123;&#125;\", iPage.getCurrent()); log.info(\"页的大小：&#123;&#125;\", iPage.getSize()); log.info(\"总页数：&#123;&#125;\", iPage.getPages()); log.info(\"总记录数：&#123;&#125;\", iPage.getTotal());&#125; 代码生成工具AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。 AutoGenerator提供了大量自定义设置，生成的代码都是基于Java代码来生成的 添加依赖MyBatis-Plus 从 3.0.3 之后移除了代码生成器与模板引擎的默认依赖，需要手动添加相关依赖： 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--模板引擎--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt; 配置生成器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Testpublic void testGenerator() &#123; // 创建代码生成器 AutoGenerator generator = new AutoGenerator(); // 全局配置 GlobalConfig globalConfig = new GlobalConfig(); globalConfig.setActiveRecord(true) // 支持AR模式 .setAuthor(\"hitopo\") // 设置作者 .setOutputDir(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\springboot-learn\\\\springboot-mybatis-plus\\\\src\\\\main\\\\java\") // 输出主目录 .setFileOverride(true) // 覆盖文件 .setIdType(IdType.AUTO) // 主键类型 .setServiceName(\"%sService\") // 生成的service名称，默认是IEmployeeService，这样改成EmployeeService .setBaseResultMap(true) // 设置XML文件中生成基本的ResultMap .setBaseColumnList(true); // 设置生成sql片段 generator.setGlobalConfig(globalConfig); // 数据源配置 DataSourceConfig dataSourceConfig = new DataSourceConfig(); dataSourceConfig.setDbType(DbType.MYSQL) .setDriverName(\"com.mysql.cj.jdbc.Driver\") .setUsername(\"root\") .setPassword(\"root\") .setUrl(\"jdbc:mysql://127.0.0.1:3306/springboot-mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai\"); generator.setDataSource(dataSourceConfig); // 策略配置 StrategyConfig strategyConfig = new StrategyConfig(); strategyConfig.setCapitalMode(true) // 全局大写命名 .setNaming(NamingStrategy.underline_to_camel) // 数据库表映射到实体的命名策略 .setTablePrefix(\"mp_\") // 表的前缀 .setInclude(\"mp_employee\"); // 设置需要生成的表 generator.setStrategy(strategyConfig); // 包名的生成配置 PackageConfig packageConfig = new PackageConfig(); packageConfig.setParent(\"com.hitopo.mpg\") // 父包名 .setMapper(\"mapper\") // Dao层包名 .setService(\"service\") // service层包名 .setController(\"controller\") // controller层包名 .setEntity(\"beans\") // 实体类包名 .setXml(\"mapper\"); // 映射文件位置 generator.setPackageInfo(packageConfig); // 执行生成器 generator.execute();&#125; 此时运行该测试，会在指定的位置生成自动生成的代码： 这里生成的EmpolyeeServiceImpl继承了ServiceImpl 在ServiceImpl中已经完成了Mapper对象的注入，直接在EmpolyeeServiceImpl中使用baseMapper即可，不需要自己再进行注入 在ServiceImpl中也帮我们提供了常用的CRUD方法，基本的CRUD在Service中也不需要再自己写方法 逻辑删除配置更改 123456mybatis-plus: global-config: db-config: logic-delete-field: flag #全局逻辑删除字段值 3.3.0开始支持，详情看下面。 logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) 局部配置：实体类的字段上添加@TableLogic注解，此方式会覆盖全局配置，如果没有注解，则会默认使用全局配置 注意： 配置逻辑删除之后，再使用Mybatis-Plus提供的删除和查询功能都会自动带上逻辑存在的字符。 也就是说，查询没有添加条件时默认只能查询到未删除记录，删除也转变成了Update语句，如果想要得到所有的记录或者想要拿到逻辑上删除的字段，只能自己写sql语句。","categories":[],"tags":[]},{"title":"Spring整合Mybatis","slug":"Spring整合Mybatis","date":"2020-04-18T10:33:31.000Z","updated":"2020-04-18T10:36:55.270Z","comments":true,"path":"2020/04/18/Spring整合Mybatis/","link":"","permalink":"http://yoursite.com/2020/04/18/Spring%E6%95%B4%E5%90%88Mybatis/","excerpt":"Spring Boot整合MybatisMybatis是一个轻量级的ORM框架，SpringBoot是最近比较流行的框架，这两者的整合同样很简单 准备准备数据表1234567891011121314151617181920212223-- create database springboot_mybatis charset utf8;DROP TABLE IF EXISTS `user`;CREATE TABLE `user`( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `username` varchar(255) DEFAULT NULL COMMENT '用户名', `password` varchar(255) DEFAULT NULL COMMENT '密码', `create_time` date DEFAULT NULL COMMENT '创建日期', PRIMARY KEY (`id`)) ENGINE = InnoDB AUTO_INCREMENT = 5 DEFAULT CHARSET = utf8;INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (5, '张三', '123', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (6, '李四', 'admin', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (7, '王五', 'root', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (8, '赵六', 'adm', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (9, 'admin', '123', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (10, 'root', '3333', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (11, 'user', '2333', '2020-04-08');","text":"Spring Boot整合MybatisMybatis是一个轻量级的ORM框架，SpringBoot是最近比较流行的框架，这两者的整合同样很简单 准备准备数据表1234567891011121314151617181920212223-- create database springboot_mybatis charset utf8;DROP TABLE IF EXISTS `user`;CREATE TABLE `user`( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `username` varchar(255) DEFAULT NULL COMMENT '用户名', `password` varchar(255) DEFAULT NULL COMMENT '密码', `create_time` date DEFAULT NULL COMMENT '创建日期', PRIMARY KEY (`id`)) ENGINE = InnoDB AUTO_INCREMENT = 5 DEFAULT CHARSET = utf8;INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (5, '张三', '123', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (6, '李四', 'admin', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (7, '王五', 'root', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (8, '赵六', 'adm', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (9, 'admin', '123', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (10, 'root', '3333', '2020-04-08');INSERT INTO `springboot-mybatis`.user (id, username, password, create_time) VALUES (11, 'user', '2333', '2020-04-08'); 引入依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 配置参数在application.yml中配置相关信息 123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver username: root password: root url: jdbc:mysql://127.0.0.1/springboot-mybatis?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai 需要注意的是driver-class-name新版的写法是com.mysql.cj.jdbc.Driver，而且在url中除了指定useUnicode和charavterEncoding之外，在SpringBoot2.0之后还必须指定serverTimeZone，否则会报错 程序中使用基本配置 之前在SSM开发时，会在MapperScannerConfigurer中配置：&lt;property name=&quot;basePackage&quot; value=&quot;xxx.mapper&quot;/&gt;用于使用Mybatis的接口代理开发模式（且接口和XML需要名称相同）。那么在SpringBoot整合Mybatis中也要有对应的配置： 方式一：在每个interface Mapper前添加@Mapper注解 方式二：在Application.java启动类前添加@MapperScan(&quot;cn.tycoding.mapper&quot;)注解 推荐使用第二种，这种包扫描的方式简化了在每个Mapper类中去配置注解 注解的方式Mybatis提供了一些注解实现快速CRUD，比如：@Select,@Update,@Insert,@Delete CRUD创建Entity实体类 com.hitopo.entity中创建User实体类User.java 1234567@Datapublic class User &#123; private Long id; private String username; private String password; private LocalDateTime createTime;&#125; 创建注解版的Mapper com.hitopo.mapper中创建UserMapperAno.java 12345678910111213141516171819202122public interface UserMapperAno &#123; @Select(\"SELECT * FROM user\") @Results(&#123; @Result(property = \"createTime\", column = \"create_time\") &#125;) List&lt;User&gt; findAll(); @Select(\"SELECT * FROM user WHERE id = #&#123;id&#125;\") @Results(&#123; @Result(property = \"createTime\", column = \"create_time\") &#125;) User findOneById(Long id); @Insert(\"INSERT INTO user(username, password, create_time) VALUES (#&#123;username&#125;,#&#123;password&#125;,#&#123;createTime&#125;)\") void save(User user); @Update(\"UPDATE user SET username=#&#123;username&#125;,password=#&#123;password&#125; WHERE id = #&#123;id&#125;\") void update(User user); @Delete(\"DELETE FROM user WHERE id = #&#123;id&#125;\") void delete(Long id);&#125; 当数据库中的字段和Java中的字段的名称不同时，使用@Result来指定如何绑定属性 测试编写测试类test/com/hitopo/mapper/UserMapperAnoTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@SpringBootTest@RunWith(SpringRunner.class)public class UserMapperAnoTest &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private UserMapperAno userMapperAno; @Test public void testFindAll() &#123; List&lt;User&gt; userList = userMapperAno.findAll(); userList.forEach(user -&gt; logger.info(\"userList=&#123;&#125;\", user)); &#125; @Test public void testFindOneById() &#123; User user = userMapperAno.findOneById(9L); logger.info(\"user=&#123;&#125;\", user); &#125; @Test public void testSave()&#123; User user = new User(); user.setUsername(\"测试用户\"); user.setPassword(\"123\"); user.setCreateTime(LocalDate.of(2010, 11, 23)); userMapperAno.save(user); testFindAll(); &#125; @Test public void testUpdate()&#123; User user = new User(); user.setId(8L); user.setUsername(\"测试用户2\"); user.setPassword(\"123444\"); user.setCreateTime(LocalDate.of(2010, 11, 23)); userMapperAno.update(user); testFindAll(); &#125; @Test public void testDelete()&#123; userMapperAno.delete(7L); testFindAll(); &#125;&#125; XML配置文件的方式基于XML配置文件的方式和基本相同，和注解版最大的不同就是Dao层，XML版会自动根据Dao层接口的方法名自动映射到XML中同名id对应的SQL 配置修改在application.yml配置文件中添加Mybatis的配置 123456789#mybatis配置mybatis: mapper-locations: classpath:mapper/**/*.xml type-aliases-package: cn.tycoding.entity configuration: # 使用jdbc的getGeneratedKeys 可以获取数据库自增主键值 use-generated-keys: true # 开启驼峰命名转换，如：Table(create_time) -&gt; Entity(createTime)。不需要我们关心怎么进行字段匹配，mybatis会自动识别`大写字母与下划线` map-underscore-to-camel-case: true CRUDcom.hitopo.mapper包内创建UserMapperXML.java 123456789101112public interface UserMapper &#123; List&lt;User&gt; findAll(); User findOneById(Long id); void save(User user); void update(User user); void delete(Long id);&#125; 在配置文件指定的mapper配置文件目录resources/mapper中创建UserMapper.xml文件 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.hitopo.mapper.UserMapperXML\"&gt; &lt;select id=\"findAll\" resultType=\"com.hitopo.entity.User\"&gt; SELECT * FROM user &lt;/select&gt; &lt;select id=\"findOneById\" resultType=\"com.hitopo.entity.User\"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;insert id=\"save\" parameterType=\"com.hitopo.entity.User\"&gt; INSERT INTO user(username, password, create_time) VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;createTime&#125;) &lt;/insert&gt; &lt;update id=\"update\" parameterType=\"com.hitopo.entity.User\"&gt; UPDATE user SET username=#&#123;username&#125;, password=#&#123;password&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; &lt;delete id=\"delete\" parameterType=\"long\"&gt; DELETE FROM user WHERE id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@SpringBootTest@RunWith(SpringRunner.class)public class UserMapperXMLTest &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private UserMapperXML userMapperXML; @Test public void testFindAll() &#123; List&lt;User&gt; userList = userMapperXML.findAll(); userList.forEach(user -&gt; logger.info(\"userList=&#123;&#125;\", user)); &#125; @Test public void testFindOneById() &#123; User user = userMapperXML.findOneById(9L); logger.info(\"user=&#123;&#125;\", user); &#125; @Test public void testSave() &#123; User user = new User(); user.setUsername(\"测试用户\"); user.setPassword(\"123\"); user.setCreateTime(LocalDate.of(2010, 11, 23)); userMapperXML.save(user); testFindAll(); &#125; @Test public void testUpdate() &#123; User user = new User(); user.setId(8L); user.setUsername(\"测试用户2\"); user.setPassword(\"123444\"); user.setCreateTime(LocalDate.of(2010, 11, 23)); userMapperXML.update(user); testFindAll(); &#125; @Test public void testDelete() &#123; userMapperXML.delete(7L); testFindAll(); &#125;&#125; 结束语Mybatis的基于注解和基于XML文件的配置方式集成到SpringBoot中都很简单，至于选择哪个方法比较好，我认为，简单的CRUD操作可以直接用注解生成，简单快捷。而复杂的动态sql和多表联结查询之类的最好放在XML文件中，方便统一管理","categories":[],"tags":[]}],"categories":[],"tags":[]}